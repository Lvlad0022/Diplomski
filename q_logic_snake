import numpy as np
from q_logic_univerzalno import Agent

items_names = {"apple": 1,
           "golden-apple": 2,
           "katana":3,
           "armour":4,
           "shorten":5,
           "tron":6,
           "freeze":7,
           "leap":8,
           "nausea":9,
           "reset-borders":10}
items_names_to_players = {
    "katana":6,
    "armour":8,
    "tron":10,
    "freeze":12,
    "loop":14, # Note: 'loop' was in your code, but 'tron' and 'freeze' were also in lasting_items and items_names_to_players. Double check these mappings.
    "golden-apple":16
}
lasting_items = [
    "katana",
    "armour",
    "tron",
    "freeze",
    "loop", # Check if 'loop' is a valid item type
    "golden-apple"]
move_names = {"up": 0, # Changed to 0, 1, 2 to match typical 3-action output (straight, right, left)
              "right": 1,
              "down": 2, # Assuming 'down' is same action as 'up' in terms of turning (straight)
              "left": 3} # Assuming 'left' is a turn left


class SimpleSnakeAgent(Agent):
    def __init__(self, player1_name, train = True,n_step_remember=1, gamma=0.93):
        super().__init__(player1_name, n_step_remember=n_step_remember)  # pozove konstruktor od Agent
        print("SimpleSnakeAgent initialized!")
        self.player1_name = player1_name
        self.player2_name = None
        self.player1_id = None # Store player IDs
        self.player2_id = None
        self.enemy_cons = 1 # Placeholder, adjust based on game state if available

    def give_reward(self, data, data_prosli):
            winner = data.get("winner")
            if winner is not None:
                self.n_games += 1
                return 1.0 if winner == 0 else -1.0

            # living bonus
            reward = 0.01

            # immediate scoring (difference)
            p1_now  = data["players"][self.player1_id]["score"]
            p1_prev = data_prosli["players"][self.player1_id]["score"]
            p2_now  = data["players"][self.player2_id]["score"]
            p2_prev = data_prosli["players"][self.player2_id]["score"]

            score_gain = (p1_now - p1_prev) /10
            reward += 0.001 * score_gain   # <- easy to feel; tune 0.005â€“0.02

            # (optional) late-game pressure if behind
            move_count = data.get("moveCount", 0)
            if move_count > 700:
                lead = (p1_now - p2_now)
                reward += 0.001 * np.tanh(lead / 5.0)

            return reward

    def get_state(self, data):
            """
            Processes the game state JSON data into map and metadata arrays.

            Args:
                data (dict): The game state data loaded from the JSON file.

            Returns:
                tuple: (metadata_array, map_array)
            """
            map_height = 25
            map_width = 60
            map_json = data["map"]
            players_json = data["players"]
            game_info = data 


            if(self.player2_name == None):# saving ids and names into agents memory if not already done 
                if(self.player1_name == players_json[0]["name"]):
                    self.player1_id = 0
                    self.player2_id = 1
                    self.player2_name = players_json[1]["name"]
                else:
                    self.player1_name = players_json[1]["name"]
                    self.player1_id = 1
                    self.player2_id = 0
                    self.player2_name = players_json[0]["name"]
            
            map_array = np.zeros((map_height, map_width, 3), dtype=np.float32) # Use float32 for torch


            # Populate the map array
            for i, row in enumerate(map_json):
                for j, item in enumerate(row):
                    if item is not None:
                        item_type = item.get("type") # Use .get() for safety
                        if item_type == "border":
                            map_array[i, j, 0] = 1  # Border channel
                        elif item_type in ["snake-body", "snake-head"]:
                            player_name = item.get("playerName")
                            if player_name == self.player1_name:
                                # Your snake body/head
                                map_array[i, j, 1] = 1 if item_type == "snake-head" else 0.5 # Your snake channel
                            elif player_name == self.player2_name:
                                # Enemy snake body/head
                                map_array[i, j, 1] = -1 if item_type == "snake-head" else -0.5 # Enemy snake channel
                        elif item_type in items_names:
                            # Item channel - use normalized item ID
                            map_array[i, j, 2] = items_names[item_type] / len(items_names) # Normalize item ID

            # --- Metadata Processing ---
            # Create arrays for player 1 and player 2 metadata
            # Ensure consistent size regardless of active items
            player1_metadata = np.zeros(18, dtype=np.float32)
            player2_metadata = np.zeros(18, dtype=np.float32)

            # Populate player 1 metadata
            if self.player1_id is not None:
                p1_data = players_json[self.player1_id]
                if p1_data["body"]: # Check if body is not empty
                    player1_metadata[0] = p1_data["body"][0]["row"] / map_height # Normalized head row
                    player1_metadata[1] = p1_data["body"][0]["column"] / map_width # Normalized head column
                # Note: Your original code used move_names[players_json[0]["lastMoveDirection"]] = 1
                # This assumes a specific mapping and a fixed size array.
                # A more flexible approach might encode direction differently or include velocity.
                # For now, keeping a placeholder based on your structure:
                last_move = p1_data.get("lastMoveDirection")
                if last_move in move_names:
                    # Set the corresponding index to 1 (assuming one-hot encoding of direction)
                    player1_metadata[move_names[last_move] + 2] = 1 # +2 because 0 and 1 are head pos

                # Add active item information
                for item in p1_data.get("activeItems", []):
                    item_type = item.config["type"]
                    #item_type = item.get("type")
                    if item_type in items_names_to_players:
                        # Set the corresponding index to 1 for the item presence
                        player1_metadata[items_names_to_players[item_type]] = 1
                        # Set the next index for normalized duration
                        player1_metadata[items_names_to_players[item_type] + 1] = item.duration / 15.0 # Normalize duration

            # Populate player 2 metadata
            if self.player2_id is not None:
                p2_data = players_json[self.player2_id]
                if p2_data["body"]: # Check if body is not empty
                    player2_metadata[0] = p2_data["body"][0]["row"] / map_height # Normalized head row
                    player2_metadata[1] = p2_data["body"][0]["column"] / map_width # Normalized head column
                last_move = p2_data.get("lastMoveDirection")
                if last_move in move_names:
                    player2_metadata[move_names[last_move] + 2] = 1 # +2 because 0 and 1 are head pos

                # Add active item information
                for item in p2_data.get("activeItems", []):
                    item_type = item.config["type"]
                    #item_type = item.get("type")
                    if item_type in items_names_to_players:
                        player2_metadata[items_names_to_players[item_type]] = 1
                        player2_metadata[items_names_to_players[item_type] + 1] = item.duration / 15.0 # Normalize duration

            # Combine player metadata and add game-level metadata
            # Correctly concatenate numerical arrays
            move_count = game_info.get("moveCount", 0)
            game_metadata = np.array([move_count / 900.0], dtype=np.float32) # Normalize move count
            points_diff = np.array([game_info["players"][self.player1_id]["score"] - game_info["players"][self.player2_id]["score"]] , dtype=np.float32)/10000

            metadata_array = np.concatenate((player1_metadata, player2_metadata, game_metadata, points_diff))

            # Ensure map_array has channels first for PyTorch CNN (C, H, W)
            map_array = np.transpose(map_array, (2, 0, 1))

            return  map_array,metadata_array # Also return the raw data for reward calculation